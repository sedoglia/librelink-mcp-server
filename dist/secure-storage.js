/**
 * Secure Storage Module for LibreLink MCP Server
 *
 * Implements secure credential storage with:
 * - AES-256-GCM encryption for data at rest
 * - Encryption keys stored in OS keychain via Keytar
 * - JWT tokens stored encrypted in user profile folder
 * - Automatic token refresh and persistence
 */
import keytar from 'keytar';
import { randomBytes, createCipheriv, createDecipheriv, scryptSync } from 'crypto';
import { readFileSync, writeFileSync, existsSync, mkdirSync, chmodSync, unlinkSync } from 'fs';
import { join } from 'path';
import { homedir } from 'os';
// Service name for keytar
const SERVICE_NAME = 'librelink-mcp-server';
const ENCRYPTION_KEY_ACCOUNT = 'encryption-key';
const AUTH_TOKEN_ACCOUNT = 'auth-token';
// Encryption constants
const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 16;
const AUTH_TAG_LENGTH = 16;
const SALT_LENGTH = 32;
const KEY_LENGTH = 32;
/**
 * SecureStorage class for managing encrypted credentials and tokens
 */
export class SecureStorage {
    constructor() {
        this.encryptionKey = null;
        this.configDir = join(homedir(), '.librelink-mcp');
        this.credentialsPath = join(this.configDir, 'credentials.enc');
        this.tokenPath = join(this.configDir, 'token.enc');
    }
    /**
     * Ensure config directory exists with proper permissions
     */
    ensureConfigDir() {
        if (!existsSync(this.configDir)) {
            mkdirSync(this.configDir, { recursive: true });
            try {
                chmodSync(this.configDir, 0o700);
            }
            catch {
                // Ignore chmod errors on Windows
            }
        }
    }
    /**
     * Get or create the encryption key from the OS keychain
     */
    async getEncryptionKey() {
        if (this.encryptionKey) {
            return this.encryptionKey;
        }
        try {
            // Try to get existing key from keychain
            const existingKey = await keytar.getPassword(SERVICE_NAME, ENCRYPTION_KEY_ACCOUNT);
            if (existingKey) {
                this.encryptionKey = Buffer.from(existingKey, 'hex');
                return this.encryptionKey;
            }
        }
        catch (error) {
            console.error('Error accessing keychain:', error);
        }
        // Generate new encryption key
        const newKey = randomBytes(KEY_LENGTH);
        try {
            await keytar.setPassword(SERVICE_NAME, ENCRYPTION_KEY_ACCOUNT, newKey.toString('hex'));
        }
        catch (error) {
            console.error('Error storing key in keychain:', error);
            throw new Error('Failed to store encryption key in system keychain. Please ensure your system supports secure credential storage.');
        }
        this.encryptionKey = newKey;
        return this.encryptionKey;
    }
    /**
     * Derive a key from the master key and salt using scrypt
     */
    deriveKey(masterKey, salt) {
        return scryptSync(masterKey, salt, KEY_LENGTH);
    }
    /**
     * Encrypt data using AES-256-GCM
     */
    async encrypt(data) {
        const masterKey = await this.getEncryptionKey();
        const salt = randomBytes(SALT_LENGTH);
        const derivedKey = this.deriveKey(masterKey, salt);
        const iv = randomBytes(IV_LENGTH);
        const cipher = createCipheriv(ALGORITHM, derivedKey, iv);
        let encrypted = cipher.update(data, 'utf8', 'base64');
        encrypted += cipher.final('base64');
        const authTag = cipher.getAuthTag();
        return {
            encrypted,
            iv: iv.toString('base64'),
            authTag: authTag.toString('base64'),
            salt: salt.toString('base64')
        };
    }
    /**
     * Decrypt data using AES-256-GCM
     */
    async decrypt(encryptedData) {
        const masterKey = await this.getEncryptionKey();
        const salt = Buffer.from(encryptedData.salt, 'base64');
        const derivedKey = this.deriveKey(masterKey, salt);
        const iv = Buffer.from(encryptedData.iv, 'base64');
        const authTag = Buffer.from(encryptedData.authTag, 'base64');
        const decipher = createDecipheriv(ALGORITHM, derivedKey, iv);
        decipher.setAuthTag(authTag);
        let decrypted = decipher.update(encryptedData.encrypted, 'base64', 'utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    }
    /**
     * Save encrypted data to file
     */
    saveEncryptedFile(path, data) {
        this.ensureConfigDir();
        writeFileSync(path, JSON.stringify(data, null, 2));
        try {
            chmodSync(path, 0o600);
        }
        catch {
            // Ignore chmod errors on Windows
        }
    }
    /**
     * Load encrypted data from file
     */
    loadEncryptedFile(path) {
        if (!existsSync(path)) {
            return null;
        }
        try {
            const data = readFileSync(path, 'utf-8');
            return JSON.parse(data);
        }
        catch {
            return null;
        }
    }
    /**
     * Store credentials securely
     */
    async saveCredentials(credentials) {
        const encrypted = await this.encrypt(JSON.stringify(credentials));
        this.saveEncryptedFile(this.credentialsPath, encrypted);
    }
    /**
     * Retrieve stored credentials
     */
    async getCredentials() {
        const encryptedData = this.loadEncryptedFile(this.credentialsPath);
        if (!encryptedData) {
            return null;
        }
        try {
            const decrypted = await this.decrypt(encryptedData);
            return JSON.parse(decrypted);
        }
        catch (error) {
            console.error('Error decrypting credentials:', error);
            return null;
        }
    }
    /**
     * Check if credentials are stored
     */
    hasCredentials() {
        return existsSync(this.credentialsPath);
    }
    /**
     * Store authentication token securely
     */
    async saveToken(tokenData) {
        const encrypted = await this.encrypt(JSON.stringify(tokenData));
        this.saveEncryptedFile(this.tokenPath, encrypted);
        // Also store a quick-access token hash in keychain for validation
        try {
            await keytar.setPassword(SERVICE_NAME, AUTH_TOKEN_ACCOUNT, tokenData.accountId);
        }
        catch {
            // Non-critical, continue without keychain token storage
        }
    }
    /**
     * Retrieve stored authentication token
     */
    async getToken() {
        const encryptedData = this.loadEncryptedFile(this.tokenPath);
        if (!encryptedData) {
            return null;
        }
        try {
            const decrypted = await this.decrypt(encryptedData);
            const tokenData = JSON.parse(decrypted);
            // Check if token is still valid (with 5 minute buffer)
            if (Date.now() < (tokenData.expires - 300000)) {
                return tokenData;
            }
            // Token expired, remove it
            await this.clearToken();
            return null;
        }
        catch (error) {
            console.error('Error decrypting token:', error);
            return null;
        }
    }
    /**
     * Check if a valid token exists
     */
    async hasValidToken() {
        const token = await this.getToken();
        return token !== null;
    }
    /**
     * Clear stored token
     */
    async clearToken() {
        if (existsSync(this.tokenPath)) {
            unlinkSync(this.tokenPath);
        }
        try {
            await keytar.deletePassword(SERVICE_NAME, AUTH_TOKEN_ACCOUNT);
        }
        catch {
            // Ignore keychain errors
        }
    }
    /**
     * Clear all stored data (credentials, tokens, and keychain entries)
     */
    async clearAll() {
        // Clear files
        if (existsSync(this.credentialsPath)) {
            unlinkSync(this.credentialsPath);
        }
        await this.clearToken();
        // Clear keychain entries
        try {
            await keytar.deletePassword(SERVICE_NAME, ENCRYPTION_KEY_ACCOUNT);
            await keytar.deletePassword(SERVICE_NAME, AUTH_TOKEN_ACCOUNT);
        }
        catch {
            // Ignore keychain errors
        }
        this.encryptionKey = null;
    }
    /**
     * Get storage paths for diagnostics
     */
    getStoragePaths() {
        return {
            configDir: this.configDir,
            credentialsPath: this.credentialsPath,
            tokenPath: this.tokenPath
        };
    }
    /**
     * Migrate from old unencrypted config.json to new secure storage
     */
    async migrateFromLegacy() {
        const legacyPath = join(this.configDir, 'config.json');
        if (!existsSync(legacyPath)) {
            return false;
        }
        try {
            const legacyData = JSON.parse(readFileSync(legacyPath, 'utf-8'));
            // Check for password in root or nested credentials object
            const email = legacyData.email || legacyData.credentials?.email;
            const password = legacyData.password || legacyData.credentials?.password;
            if (email && password) {
                // Save credentials to new secure storage
                await this.saveCredentials({ email, password });
                console.error('Migrated credentials from legacy config to secure storage');
                // Remove all sensitive data from legacy file
                delete legacyData.password;
                delete legacyData.email;
                delete legacyData.credentials;
                // Keep only non-sensitive settings
                const cleanConfig = {
                    region: legacyData.region || 'EU',
                    targetLow: legacyData.targetLow || legacyData.ranges?.target_low || 70,
                    targetHigh: legacyData.targetHigh || legacyData.ranges?.target_high || 180,
                    clientVersion: legacyData.clientVersion || '4.16.0'
                };
                writeFileSync(legacyPath, JSON.stringify(cleanConfig, null, 2));
                return true;
            }
        }
        catch (error) {
            console.error('Error migrating legacy config:', error);
        }
        return false;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjdXJlLXN0b3JhZ2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvc2VjdXJlLXN0b3JhZ2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFFSCxPQUFPLE1BQU0sTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxFQUFFLFdBQVcsRUFBRSxjQUFjLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQ25GLE9BQU8sRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLElBQUksQ0FBQztBQUMvRixPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzVCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFFN0IsMEJBQTBCO0FBQzFCLE1BQU0sWUFBWSxHQUFHLHNCQUFzQixDQUFDO0FBQzVDLE1BQU0sc0JBQXNCLEdBQUcsZ0JBQWdCLENBQUM7QUFDaEQsTUFBTSxrQkFBa0IsR0FBRyxZQUFZLENBQUM7QUFFeEMsdUJBQXVCO0FBQ3ZCLE1BQU0sU0FBUyxHQUFHLGFBQWEsQ0FBQztBQUNoQyxNQUFNLFNBQVMsR0FBRyxFQUFFLENBQUM7QUFDckIsTUFBTSxlQUFlLEdBQUcsRUFBRSxDQUFDO0FBQzNCLE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQztBQUN2QixNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFzQnRCOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGFBQWE7SUFNeEI7UUFGUSxrQkFBYSxHQUFrQixJQUFJLENBQUM7UUFHMUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUNuRCxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLGlCQUFpQixDQUFDLENBQUM7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QUF5QztnQkFDekMsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7Z0JBRWhELE9BQU8sQ0FBQyxLQUFLLENBQUMsMkRBQTJELENBQUMsQ0FBQztnQkFFM0UsNkNBQTZDO2dCQUM3QyxPQUFPLFVBQVUsQ0FBQyxRQUFRLENBQUM7Z0JBQzNCLE9BQU8sVUFBVSxDQUFDLEtBQUssQ0FBQztnQkFDeEIsT0FBTyxVQUFVLENBQUMsV0FBVyxDQUFDO2dCQUU5QixtQ0FBbUM7Z0JBQ25DLE1BQU0sV0FBVyxHQUFHO29CQUNsQixNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU0sSUFBSSxJQUFJO29CQUNqQyxTQUFTLEVBQUUsVUFBVSxDQUFDLFNBQVMsSUFBSSxVQUFVLENBQUMsTUFBTSxFQUFFLFVBQVUsSUFBSSxFQUFFO29CQUN0RSxVQUFVLEVBQUUsVUFBVSxDQUFDLFVBQVUsSUFBSSxVQUFVLENBQUMsTUFBTSxFQUFFLFdBQVcsSUFBSSxHQUFHO29CQUMxRSxhQUFhLEVBQUUsVUFBVSxDQUFDLGFBQWEsSUFBSSxRQUFRO2lCQUNwRCxDQUFDO2dCQUVGLGFBQWEsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBRWhFLE9BQU8sSUFBSSxDQUFDO1lBQ2QsQ0FBQztRQUNILENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsT0FBTyxDQUFDLEtBQUssQ0FBQyxnQ0FBZ0MsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN6RCxDQUFDO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNlY3VyZSBTdG9yYWdlIE1vZHVsZSBmb3IgTGlicmVMaW5rIE1DUCBTZXJ2ZXJcbiAqXG4gKiBJbXBsZW1lbnRzIHNlY3VyZSBjcmVkZW50aWFsIHN0b3JhZ2Ugd2l0aDpcbiAqIC0gQUVTLTI1Ni1HQ00gZW5jcnlwdGlvbiBmb3IgZGF0YSBhdCByZXN0XG4gKiAtIEVuY3J5cHRpb24ga2V5cyBzdG9yZWQgaW4gT1Mga2V5Y2hhaW4gdmlhIEtleXRhclxuICogLSBKV1QgdG9rZW5zIHN0b3JlZCBlbmNyeXB0ZWQgaW4gdXNlciBwcm9maWxlIGZvbGRlclxuICogLSBBdXRvbWF0aWMgdG9rZW4gcmVmcmVzaCBhbmQgcGVyc2lzdGVuY2VcbiAqL1xuXG5pbXBvcnQga2V5dGFyIGZyb20gJ2tleXRhcic7XG5pbXBvcnQgeyByYW5kb21CeXRlcywgY3JlYXRlQ2lwaGVyaXYsIGNyZWF0ZURlY2lwaGVyaXYsIHNjcnlwdFN5bmMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgcmVhZEZpbGVTeW5jLCB3cml0ZUZpbGVTeW5jLCBleGlzdHNTeW5jLCBta2RpclN5bmMsIGNobW9kU3luYywgdW5saW5rU3luYyB9IGZyb20gJ2ZzJztcbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IGhvbWVkaXIgfSBmcm9tICdvcyc7XG5cbi8vIFNlcnZpY2UgbmFtZSBmb3Iga2V5dGFyXG5jb25zdCBTRVJWSUNFX05BTUUgPSAnbGlicmVsaW5rLW1jcC1zZXJ2ZXInO1xuY29uc3QgRU5DUllQVElPTl9LRVlfQUNDT1VOVCA9ICdlbmNyeXB0aW9uLWtleSc7XG5jb25zdCBBVVRIX1RPS0VOX0FDQ09VTlQgPSAnYXV0aC10b2tlbic7XG5cbi8vIEVuY3J5cHRpb24gY29uc3RhbnRzXG5jb25zdCBBTEdPUklUSE0gPSAnYWVzLTI1Ni1nY20nO1xuY29uc3QgSVZfTEVOR1RIID0gMTY7XG5jb25zdCBBVVRIX1RBR19MRU5HVEggPSAxNjtcbmNvbnN0IFNBTFRfTEVOR1RIID0gMzI7XG5jb25zdCBLRVlfTEVOR1RIID0gMzI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VjdXJlQ3JlZGVudGlhbHMge1xuICBlbWFpbDogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0b3JlZFRva2VuRGF0YSB7XG4gIHRva2VuOiBzdHJpbmc7XG4gIGV4cGlyZXM6IG51bWJlcjsgLy8gdGltZXN0YW1wIGluIG1zXG4gIHVzZXJJZDogc3RyaW5nO1xuICBhY2NvdW50SWQ6IHN0cmluZzsgLy8gU0hBMjU2IGhhc2ggb2YgdXNlcklkXG4gIHJlZ2lvbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVuY3J5cHRlZERhdGEge1xuICBlbmNyeXB0ZWQ6IHN0cmluZzsgLy8gYmFzZTY0XG4gIGl2OiBzdHJpbmc7IC8vIGJhc2U2NFxuICBhdXRoVGFnOiBzdHJpbmc7IC8vIGJhc2U2NFxuICBzYWx0OiBzdHJpbmc7IC8vIGJhc2U2NFxufVxuXG4vKipcbiAqIFNlY3VyZVN0b3JhZ2UgY2xhc3MgZm9yIG1hbmFnaW5nIGVuY3J5cHRlZCBjcmVkZW50aWFscyBhbmQgdG9rZW5zXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWN1cmVTdG9yYWdlIHtcbiAgcHJpdmF0ZSBjb25maWdEaXI6IHN0cmluZztcbiAgcHJpdmF0ZSBjcmVkZW50aWFsc1BhdGg6IHN0cmluZztcbiAgcHJpdmF0ZSB0b2tlblBhdGg6IHN0cmluZztcbiAgcHJpdmF0ZSBlbmNyeXB0aW9uS2V5OiBCdWZmZXIgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbmZpZ0RpciA9IGpvaW4oaG9tZWRpcigpLCAnLmxpYnJlbGluay1tY3AnKTtcbiAgICB0aGlzLmNyZWRlbnRpYWxzUGF0aCA9IGpvaW4odGhpcy5jb25maWdEaXIsICdjcmVkZW50aWFscy5lbmMnKTtcbiAgICB0aGlzLnRva2VuUGF0aCA9IGpvaW4odGhpcy5jb25maWdEaXIsICd0b2tlbi5lbmMnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgY29uZmlnIGRpcmVjdG9yeSBleGlzdHMgd2l0aCBwcm9wZXIgcGVybWlzc2lvbnNcbiAgICovXG4gIHByaXZhdGUgZW5zdXJlQ29uZmlnRGlyKCk6IHZvaWQge1xuICAgIGlmICghZXhpc3RzU3luYyh0aGlzLmNvbmZpZ0RpcikpIHtcbiAgICAgIG1rZGlyU3luYyh0aGlzLmNvbmZpZ0RpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBjaG1vZFN5bmModGhpcy5jb25maWdEaXIsIDBvNzAwKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBJZ25vcmUgY2htb2QgZXJyb3JzIG9uIFdpbmRvd3NcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9yIGNyZWF0ZSB0aGUgZW5jcnlwdGlvbiBrZXkgZnJvbSB0aGUgT1Mga2V5Y2hhaW5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2V0RW5jcnlwdGlvbktleSgpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGlmICh0aGlzLmVuY3J5cHRpb25LZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRpb25LZXk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRyeSB0byBnZXQgZXhpc3Rpbmcga2V5IGZyb20ga2V5Y2hhaW5cbiAgICAgIGNvbnN0IGV4aXN0aW5nS2V5ID0gYXdhaXQga2V5dGFyLmdldFBhc3N3b3JkKFNFUlZJQ0VfTkFNRSwgRU5DUllQVElPTl9LRVlfQUNDT1VOVCk7XG5cbiAgICAgIGlmIChleGlzdGluZ0tleSkge1xuICAgICAgICB0aGlzLmVuY3J5cHRpb25LZXkgPSBCdWZmZXIuZnJvbShleGlzdGluZ0tleSwgJ2hleCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uS2V5O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhY2Nlc3Npbmcga2V5Y2hhaW46JywgZXJyb3IpO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIG5ldyBlbmNyeXB0aW9uIGtleVxuICAgIGNvbnN0IG5ld0tleSA9IHJhbmRvbUJ5dGVzKEtFWV9MRU5HVEgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGtleXRhci5zZXRQYXNzd29yZChTRVJWSUNFX05BTUUsIEVOQ1JZUFRJT05fS0VZX0FDQ09VTlQsIG5ld0tleS50b1N0cmluZygnaGV4JykpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdG9yaW5nIGtleSBpbiBrZXljaGFpbjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzdG9yZSBlbmNyeXB0aW9uIGtleSBpbiBzeXN0ZW0ga2V5Y2hhaW4uIFBsZWFzZSBlbnN1cmUgeW91ciBzeXN0ZW0gc3VwcG9ydHMgc2VjdXJlIGNyZWRlbnRpYWwgc3RvcmFnZS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmVuY3J5cHRpb25LZXkgPSBuZXdLZXk7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbktleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSBrZXkgZnJvbSB0aGUgbWFzdGVyIGtleSBhbmQgc2FsdCB1c2luZyBzY3J5cHRcbiAgICovXG4gIHByaXZhdGUgZGVyaXZlS2V5KG1hc3RlcktleTogQnVmZmVyLCBzYWx0OiBCdWZmZXIpOiBCdWZmZXIge1xuICAgIHJldHVybiBzY3J5cHRTeW5jKG1hc3RlcktleSwgc2FsdCwgS0VZX0xFTkdUSCk7XG4gIH1cblxuICAvKipcbiAgICogRW5jcnlwdCBkYXRhIHVzaW5nIEFFUy0yNTYtR0NNXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGVuY3J5cHQoZGF0YTogc3RyaW5nKTogUHJvbWlzZTxFbmNyeXB0ZWREYXRhPiB7XG4gICAgY29uc3QgbWFzdGVyS2V5ID0gYXdhaXQgdGhpcy5nZXRFbmNyeXB0aW9uS2V5KCk7XG4gICAgY29uc3Qgc2FsdCA9IHJhbmRvbUJ5dGVzKFNBTFRfTEVOR1RIKTtcbiAgICBjb25zdCBkZXJpdmVkS2V5ID0gdGhpcy5kZXJpdmVLZXkobWFzdGVyS2V5LCBzYWx0KTtcbiAgICBjb25zdCBpdiA9IHJhbmRvbUJ5dGVzKElWX0xFTkdUSCk7XG5cbiAgICBjb25zdCBjaXBoZXIgPSBjcmVhdGVDaXBoZXJpdihBTEdPUklUSE0sIGRlcml2ZWRLZXksIGl2KTtcblxuICAgIGxldCBlbmNyeXB0ZWQgPSBjaXBoZXIudXBkYXRlKGRhdGEsICd1dGY4JywgJ2Jhc2U2NCcpO1xuICAgIGVuY3J5cHRlZCArPSBjaXBoZXIuZmluYWwoJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgYXV0aFRhZyA9IGNpcGhlci5nZXRBdXRoVGFnKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZW5jcnlwdGVkLFxuICAgICAgaXY6IGl2LnRvU3RyaW5nKCdiYXNlNjQnKSxcbiAgICAgIGF1dGhUYWc6IGF1dGhUYWcudG9TdHJpbmcoJ2Jhc2U2NCcpLFxuICAgICAgc2FsdDogc2FsdC50b1N0cmluZygnYmFzZTY0JylcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY3J5cHQgZGF0YSB1c2luZyBBRVMtMjU2LUdDTVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBkZWNyeXB0KGVuY3J5cHRlZERhdGE6IEVuY3J5cHRlZERhdGEpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IG1hc3RlcktleSA9IGF3YWl0IHRoaXMuZ2V0RW5jcnlwdGlvbktleSgpO1xuICAgIGNvbnN0IHNhbHQgPSBCdWZmZXIuZnJvbShlbmNyeXB0ZWREYXRhLnNhbHQsICdiYXNlNjQnKTtcbiAgICBjb25zdCBkZXJpdmVkS2V5ID0gdGhpcy5kZXJpdmVLZXkobWFzdGVyS2V5LCBzYWx0KTtcbiAgICBjb25zdCBpdiA9IEJ1ZmZlci5mcm9tKGVuY3J5cHRlZERhdGEuaXYsICdiYXNlNjQnKTtcbiAgICBjb25zdCBhdXRoVGFnID0gQnVmZmVyLmZyb20oZW5jcnlwdGVkRGF0YS5hdXRoVGFnLCAnYmFzZTY0Jyk7XG5cbiAgICBjb25zdCBkZWNpcGhlciA9IGNyZWF0ZURlY2lwaGVyaXYoQUxHT1JJVEhNLCBkZXJpdmVkS2V5LCBpdik7XG4gICAgZGVjaXBoZXIuc2V0QXV0aFRhZyhhdXRoVGFnKTtcblxuICAgIGxldCBkZWNyeXB0ZWQgPSBkZWNpcGhlci51cGRhdGUoZW5jcnlwdGVkRGF0YS5lbmNyeXB0ZWQsICdiYXNlNjQnLCAndXRmOCcpO1xuICAgIGRlY3J5cHRlZCArPSBkZWNpcGhlci5maW5hbCgndXRmOCcpO1xuXG4gICAgcmV0dXJuIGRlY3J5cHRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlIGVuY3J5cHRlZCBkYXRhIHRvIGZpbGVcbiAgICovXG4gIHByaXZhdGUgc2F2ZUVuY3J5cHRlZEZpbGUocGF0aDogc3RyaW5nLCBkYXRhOiBFbmNyeXB0ZWREYXRhKTogdm9pZCB7XG4gICAgdGhpcy5lbnN1cmVDb25maWdEaXIoKTtcbiAgICB3cml0ZUZpbGVTeW5jKHBhdGgsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcbiAgICB0cnkge1xuICAgICAgY2htb2RTeW5jKHBhdGgsIDBvNjAwKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIElnbm9yZSBjaG1vZCBlcnJvcnMgb24gV2luZG93c1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGVuY3J5cHRlZCBkYXRhIGZyb20gZmlsZVxuICAgKi9cbiAgcHJpdmF0ZSBsb2FkRW5jcnlwdGVkRmlsZShwYXRoOiBzdHJpbmcpOiBFbmNyeXB0ZWREYXRhIHwgbnVsbCB7XG4gICAgaWYgKCFleGlzdHNTeW5jKHBhdGgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IHJlYWRGaWxlU3luYyhwYXRoLCAndXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpIGFzIEVuY3J5cHRlZERhdGE7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcmUgY3JlZGVudGlhbHMgc2VjdXJlbHlcbiAgICovXG4gIGFzeW5jIHNhdmVDcmVkZW50aWFscyhjcmVkZW50aWFsczogU2VjdXJlQ3JlZGVudGlhbHMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCB0aGlzLmVuY3J5cHQoSlNPTi5zdHJpbmdpZnkoY3JlZGVudGlhbHMpKTtcbiAgICB0aGlzLnNhdmVFbmNyeXB0ZWRGaWxlKHRoaXMuY3JlZGVudGlhbHNQYXRoLCBlbmNyeXB0ZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHN0b3JlZCBjcmVkZW50aWFsc1xuICAgKi9cbiAgYXN5bmMgZ2V0Q3JlZGVudGlhbHMoKTogUHJvbWlzZTxTZWN1cmVDcmVkZW50aWFscyB8IG51bGw+IHtcbiAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gdGhpcy5sb2FkRW5jcnlwdGVkRmlsZSh0aGlzLmNyZWRlbnRpYWxzUGF0aCk7XG4gICAgaWYgKCFlbmNyeXB0ZWREYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgdGhpcy5kZWNyeXB0KGVuY3J5cHRlZERhdGEpO1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjcnlwdGVkKSBhcyBTZWN1cmVDcmVkZW50aWFscztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVjcnlwdGluZyBjcmVkZW50aWFsczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgY3JlZGVudGlhbHMgYXJlIHN0b3JlZFxuICAgKi9cbiAgaGFzQ3JlZGVudGlhbHMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGV4aXN0c1N5bmModGhpcy5jcmVkZW50aWFsc1BhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlIGF1dGhlbnRpY2F0aW9uIHRva2VuIHNlY3VyZWx5XG4gICAqL1xuICBhc3luYyBzYXZlVG9rZW4odG9rZW5EYXRhOiBTdG9yZWRUb2tlbkRhdGEpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCB0aGlzLmVuY3J5cHQoSlNPTi5zdHJpbmdpZnkodG9rZW5EYXRhKSk7XG4gICAgdGhpcy5zYXZlRW5jcnlwdGVkRmlsZSh0aGlzLnRva2VuUGF0aCwgZW5jcnlwdGVkKTtcblxuICAgIC8vIEFsc28gc3RvcmUgYSBxdWljay1hY2Nlc3MgdG9rZW4gaGFzaCBpbiBrZXljaGFpbiBmb3IgdmFsaWRhdGlvblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBrZXl0YXIuc2V0UGFzc3dvcmQoU0VSVklDRV9OQU1FLCBBVVRIX1RPS0VOX0FDQ09VTlQsIHRva2VuRGF0YS5hY2NvdW50SWQpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gTm9uLWNyaXRpY2FsLCBjb250aW51ZSB3aXRob3V0IGtleWNoYWluIHRva2VuIHN0b3JhZ2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgc3RvcmVkIGF1dGhlbnRpY2F0aW9uIHRva2VuXG4gICAqL1xuICBhc3luYyBnZXRUb2tlbigpOiBQcm9taXNlPFN0b3JlZFRva2VuRGF0YSB8IG51bGw+IHtcbiAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gdGhpcy5sb2FkRW5jcnlwdGVkRmlsZSh0aGlzLnRva2VuUGF0aCk7XG4gICAgaWYgKCFlbmNyeXB0ZWREYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgdGhpcy5kZWNyeXB0KGVuY3J5cHRlZERhdGEpO1xuICAgICAgY29uc3QgdG9rZW5EYXRhID0gSlNPTi5wYXJzZShkZWNyeXB0ZWQpIGFzIFN0b3JlZFRva2VuRGF0YTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdG9rZW4gaXMgc3RpbGwgdmFsaWQgKHdpdGggNSBtaW51dGUgYnVmZmVyKVxuICAgICAgaWYgKERhdGUubm93KCkgPCAodG9rZW5EYXRhLmV4cGlyZXMgLSAzMDAwMDApKSB7XG4gICAgICAgIHJldHVybiB0b2tlbkRhdGE7XG4gICAgICB9XG5cbiAgICAgIC8vIFRva2VuIGV4cGlyZWQsIHJlbW92ZSBpdFxuICAgICAgYXdhaXQgdGhpcy5jbGVhclRva2VuKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVjcnlwdGluZyB0b2tlbjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB2YWxpZCB0b2tlbiBleGlzdHNcbiAgICovXG4gIGFzeW5jIGhhc1ZhbGlkVG9rZW4oKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmdldFRva2VuKCk7XG4gICAgcmV0dXJuIHRva2VuICE9PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIHN0b3JlZCB0b2tlblxuICAgKi9cbiAgYXN5bmMgY2xlYXJUb2tlbigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoZXhpc3RzU3luYyh0aGlzLnRva2VuUGF0aCkpIHtcbiAgICAgIHVubGlua1N5bmModGhpcy50b2tlblBhdGgpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBrZXl0YXIuZGVsZXRlUGFzc3dvcmQoU0VSVklDRV9OQU1FLCBBVVRIX1RPS0VOX0FDQ09VTlQpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSWdub3JlIGtleWNoYWluIGVycm9yc1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgc3RvcmVkIGRhdGEgKGNyZWRlbnRpYWxzLCB0b2tlbnMsIGFuZCBrZXljaGFpbiBlbnRyaWVzKVxuICAgKi9cbiAgYXN5bmMgY2xlYXJBbGwoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gQ2xlYXIgZmlsZXNcbiAgICBpZiAoZXhpc3RzU3luYyh0aGlzLmNyZWRlbnRpYWxzUGF0aCkpIHtcbiAgICAgIHVubGlua1N5bmModGhpcy5jcmVkZW50aWFsc1BhdGgpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmNsZWFyVG9rZW4oKTtcblxuICAgIC8vIENsZWFyIGtleWNoYWluIGVudHJpZXNcbiAgICB0cnkge1xuICAgICAgYXdhaXQga2V5dGFyLmRlbGV0ZVBhc3N3b3JkKFNFUlZJQ0VfTkFNRSwgRU5DUllQVElPTl9LRVlfQUNDT1VOVCk7XG4gICAgICBhd2FpdCBrZXl0YXIuZGVsZXRlUGFzc3dvcmQoU0VSVklDRV9OQU1FLCBBVVRIX1RPS0VOX0FDQ09VTlQpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSWdub3JlIGtleWNoYWluIGVycm9yc1xuICAgIH1cblxuICAgIHRoaXMuZW5jcnlwdGlvbktleSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN0b3JhZ2UgcGF0aHMgZm9yIGRpYWdub3N0aWNzXG4gICAqL1xuICBnZXRTdG9yYWdlUGF0aHMoKTogeyBjb25maWdEaXI6IHN0cmluZzsgY3JlZGVudGlhbHNQYXRoOiBzdHJpbmc7IHRva2VuUGF0aDogc3RyaW5nIH0ge1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWdEaXI6IHRoaXMuY29uZmlnRGlyLFxuICAgICAgY3JlZGVudGlhbHNQYXRoOiB0aGlzLmNyZWRlbnRpYWxzUGF0aCxcbiAgICAgIHRva2VuUGF0aDogdGhpcy50b2tlblBhdGhcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE1pZ3JhdGUgZnJvbSBvbGQgdW5lbmNyeXB0ZWQgY29uZmlnLmpzb24gdG8gbmV3IHNlY3VyZSBzdG9yYWdlXG4gICAqL1xuICBhc3luYyBtaWdyYXRlRnJvbUxlZ2FjeSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBsZWdhY3lQYXRoID0gam9pbih0aGlzLmNvbmZpZ0RpciwgJ2NvbmZpZy5qc29uJyk7XG5cbiAgICBpZiAoIWV4aXN0c1N5bmMobGVnYWN5UGF0aCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgbGVnYWN5RGF0YSA9IEpTT04ucGFyc2UocmVhZEZpbGVTeW5jKGxlZ2FjeVBhdGgsICd1dGYtOCcpKTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIHBhc3N3b3JkIGluIHJvb3Qgb3IgbmVzdGVkIGNyZWRlbnRpYWxzIG9iamVjdFxuICAgICAgY29uc3QgZW1haWwgPSBsZWdhY3lEYXRhLmVtYWlsIHx8IGxlZ2FjeURhdGEuY3JlZGVudGlhbHM/LmVtYWlsO1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSBsZWdhY3lEYXRhLnBhc3N3b3JkIHx8IGxlZ2FjeURhdGEuY3JlZGVudGlhbHM/LnBhc3N3b3JkO1xuXG4gICAgICBpZiAoZW1haWwgJiYgcGFzc3dvcmQpIHtcbiAgICAgICAgLy8gU2F2ZSBjcmVkZW50aWFscyB0byBuZXcgc2VjdXJlIHN0b3JhZ2VcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlQ3JlZGVudGlhbHMoeyBlbWFpbCwgcGFzc3dvcmQgfSk7XG5cbiAgICAgICAgY29uc29sZS5lcnJvcignTWlncmF0ZWQgY3JlZGVudGlhbHMgZnJvbSBsZWdhY3kgY29uZmlnIHRvIHNlY3VyZSBzdG9yYWdlJyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBzZW5zaXRpdmUgZGF0YSBmcm9tIGxlZ2FjeSBmaWxlXG4gICAgICAgIGRlbGV0ZSBsZWdhY3lEYXRhLnBhc3N3b3JkO1xuICAgICAgICBkZWxldGUgbGVnYWN5RGF0YS5lbWFpbDtcbiAgICAgICAgZGVsZXRlIGxlZ2FjeURhdGEuY3JlZGVudGlhbHM7XG5cbiAgICAgICAgLy8gS2VlcCBvbmx5IG5vbi1zZW5zaXRpdmUgc2V0dGluZ3NcbiAgICAgICAgY29uc3QgY2xlYW5Db25maWcgPSB7XG4gICAgICAgICAgcmVnaW9uOiBsZWdhY3lEYXRhLnJlZ2lvbiB8fCAnRVUnLFxuICAgICAgICAgIHRhcmdldExvdzogbGVnYWN5RGF0YS50YXJnZXRMb3cgfHwgbGVnYWN5RGF0YS5yYW5nZXM/LnRhcmdldF9sb3cgfHwgNzAsXG4gICAgICAgICAgdGFyZ2V0SGlnaDogbGVnYWN5RGF0YS50YXJnZXRIaWdoIHx8IGxlZ2FjeURhdGEucmFuZ2VzPy50YXJnZXRfaGlnaCB8fCAxODAsXG4gICAgICAgICAgY2xpZW50VmVyc2lvbjogbGVnYWN5RGF0YS5jbGllbnRWZXJzaW9uIHx8ICc0LjE2LjAnXG4gICAgICAgIH07XG5cbiAgICAgICAgd3JpdGVGaWxlU3luYyhsZWdhY3lQYXRoLCBKU09OLnN0cmluZ2lmeShjbGVhbkNvbmZpZywgbnVsbCwgMikpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtaWdyYXRpbmcgbGVnYWN5IGNvbmZpZzonLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXX0=